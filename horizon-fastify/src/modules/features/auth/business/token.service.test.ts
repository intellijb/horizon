import { describe, it, expect, beforeEach } from "@jest/globals"
import { TokenService } from "./token.service"
import { AuthConstants } from "../constants/auth.constants"
import { AuthError } from "../constants/error.codes"

describe("TokenService", () => {
  let tokenService: TokenService

  beforeEach(() => {
    tokenService = new TokenService()
  })

  describe("generateTokenPair", () => {
    it("should generate access and refresh token pair", () => {
      const payload = {
        userId: "user-123",
        email: "test@example.com",
        role: "user",
        deviceId: "device-123",
        sessionId: "session-123",
      }

      const result = tokenService.generateTokenPair(payload)

      expect(result).toHaveProperty("accessToken")
      expect(result).toHaveProperty("refreshToken")
      expect(result).toHaveProperty("expiresIn", AuthConstants.ACCESS_TOKEN_EXPIRES_IN)
      expect(result).toHaveProperty("tokenType", AuthConstants.TOKEN_TYPE)
      expect(typeof result.accessToken).toBe("string")
      expect(typeof result.refreshToken).toBe("string")
      expect(result.accessToken).not.toBe(result.refreshToken)
    })
  })

  describe("generateRandomToken", () => {
    it("should generate random token with default bytes", () => {
      const result = tokenService.generateRandomToken()

      expect(typeof result).toBe("string")
      expect(result.length).toBeGreaterThan(0)
    })

    it("should generate random token with custom bytes", () => {
      const result = tokenService.generateRandomToken(64)

      expect(typeof result).toBe("string")
      expect(result.length).toBeGreaterThan(0)
    })

    it("should generate different tokens on each call", () => {
      const token1 = tokenService.generateRandomToken()
      const token2 = tokenService.generateRandomToken()

      expect(token1).not.toBe(token2)
    })
  })

  describe("generateSessionId", () => {
    it("should generate a UUID session ID", () => {
      const result = tokenService.generateSessionId()

      expect(typeof result).toBe("string")
      // UUID v4 format: xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx
      expect(result).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      )
    })

    it("should generate unique session IDs", () => {
      const id1 = tokenService.generateSessionId()
      const id2 = tokenService.generateSessionId()

      expect(id1).not.toBe(id2)
    })
  })

  describe("verifyAccessToken", () => {
    it("should verify a valid token generated by the same service", () => {
      const payload = {
        userId: "user-123",
        email: "test@example.com",
        role: "user",
        deviceId: "device-123",
        sessionId: "session-123",
      }

      const { accessToken } = tokenService.generateTokenPair(payload)
      const decoded = tokenService.verifyAccessToken(accessToken)

      expect(decoded.userId).toBe(payload.userId)
      expect(decoded.email).toBe(payload.email)
      expect(decoded.role).toBe(payload.role)
      expect(decoded.deviceId).toBe(payload.deviceId)
      expect(decoded.sessionId).toBe(payload.sessionId)
    })

    it("should throw AuthError for invalid token", () => {
      expect(() => {
        tokenService.verifyAccessToken("invalid.token.here")
      }).toThrow(AuthError)
    })

    it("should throw AuthError for malformed token", () => {
      expect(() => {
        tokenService.verifyAccessToken("not-a-jwt")
      }).toThrow(AuthError)
    })
  })

  describe("verifyRefreshToken", () => {
    it("should verify a valid refresh token", () => {
      const payload = {
        userId: "user-123",
        email: "test@example.com",
        role: "user",
        deviceId: "device-123",
        sessionId: "session-123",
      }

      const { refreshToken } = tokenService.generateTokenPair(payload)
      const decoded = tokenService.verifyRefreshToken(refreshToken)

      expect(decoded.userId).toBe(payload.userId)
      expect(decoded.deviceId).toBe(payload.deviceId)
      expect(decoded.sessionId).toBe(payload.sessionId)
    })

    it("should throw AuthError for invalid refresh token", () => {
      expect(() => {
        tokenService.verifyRefreshToken("invalid.refresh.token")
      }).toThrow(AuthError)
    })
  })
})